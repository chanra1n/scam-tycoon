<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Scam Tycoon</title>
  <!-- UIkit CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.17.11/dist/css/uikit.min.css" />

  <!-- UIkit JS -->
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.17.11/dist/js/uikit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.17.11/dist/js/uikit-icons.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.1.0/remixicon.min.css"
    integrity="sha512-i5VzKip7owqOGjb0YTF8MR2J9yBVO3FLHeazKzLp354XYTmKcqEU3UeFYUw82R8tV6JqxeATOfstCfpfPhbyEA=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="crt.css">
  <link rel="stylesheet" href="vig.css">
  <script src='https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js'></script>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
  <style>
    /*add my custom fonts*/

    @font-face {
      font-family: "gamer";
      src: url("sprites/gamer.ttf");
    }

    @font-face {
      font-family: "beeg";
      src: url("sprites/8bitfont.ttf");
    }

    body,
    html {
      height: 100%;
      margin: 0;
      padding: 0px;
      width: 100%;
      overflow: hidden;
      filter: brightness(1.2);
      font-family: 'gamer';
    }


    .grid-container {
      display: grid;
      grid-template-columns: repeat(48, 1fr);
      grid-template-rows: repeat(48, 1fr);
      background-color: #ccc;
      width: 100%;
      height: 100%;
      position: relative;
      margin: 0px;
    }

    .grid-item {
      background-color: #e9e9e9;
      outline: 1.5px solid #c3c3c320;
      box-sizing: border-box;
      background-image: url('sprites/city_block.png');
      background-size: 100%;
      background-repeat: no-repeat;
      image-rendering: pixelated;

    }


    #navbar {
      position: fixed;
      bottom: 0;
      z-index: 1000;
      background-color: black;
      box-sizing: border-box;
      width: 98%;
      margin: 1%;
      border-radius: 7.5px;
      font-weight: 900;
      font-size: 20px;
      color: white;
      opacity: 50%;
      vertical-align: middle;
      display: flex;
      padding: 10px;
    }

    #navbar:hover {
      opacity: 100%;
    }

    #navbar button {
      color: white;
      border: none;
      font-size: 20px;
      background-color: transparent;
      border-radius: 100vmin;
      aspect-ratio: 1/1;
      cursor: pointer;
    }

    #topbar {
      position: absolute;
    top: 0;
    left: 0;
    z-index: 10000;
    background-color: black;
    width: 100%;
    font-weight: 900;
    font-size: 20px;
    vertical-align: middle;
    padding: 0px;
    margin: 0px;
    text-align: right;
    box-sizing: border-box;
    }

    #topbar p:nth-child(even) {
      background-color: transparent;
    }

    #topbar p:nth-child(odd) {
      background-color: #1a1a1a;
    }

    #topbar p {
      font-weight: 100;
      font-size: 25px;
      padding: 0px;
      margin: 0px;
      vertical-align: middle;
      display: inline-block;
      padding-left: 10px;
      padding-right: 10px;
      white-space: normal;
      border: 5px solid transparent;
    }

    #topbar p i {
      font-size: 16px;
    }

    .tippy-box {
  background-color: #000;
  font-family:'Consolas', 'Courier New', Courier, monospace;
}

  </style>
    <link rel="stylesheet" href="zones.css">
    <link rel="stylesheet" href="buildings.css">
</head>

<body>
  <div class="vignette"></div>
  <div class="crt"></div>
  <div id="topbar">

    <div style="float:left">
      <select id="building-select">
        <option value="police-station">Police Station</option>
        <option value="fire-station">Fire Station</option>
        <!-- Add more options as needed -->
      </select>
      <button id="toggle-building-mode"><i class="ri-hammer-fill"></i></button>
    </div>
    <div style="float:right;display:flex;">
    <p id="player-money"> <i class="ri-money-dollar-circle-fill"></i> 0</p>
    <p id="player-level"><i class="ri-shield-fill"></i> 00</p>
    <p id="employee-count"><i class="ri-user-5-fill"></i> 0</p>
    <p id="building-count"><i class="ri-hotel-fill"></i> 0</p>
</div>

  </div>
  <div id="navbar">





  </div>
  <div id="world-map" class="grid-container"></div>

  <script>

    const gridSize = 48;
    const gridContainer = document.querySelector(".grid-container");

    const cityLayout = generateCityLayout(gridSize);

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        const gridItem = document.createElement("div");
        gridItem.classList.add("grid-item");
        gridItem.classList.add(cityLayout[i][j]);
        gridContainer.appendChild(gridItem);
        gridItem.dataset.position = `${i},${j}`;


        if (cityLayout[i][j] === "road") {
          const isRoadAbove = i > 0 && cityLayout[i - 1][j] === "road";
          const isRoadBelow = i < gridSize - 1 && cityLayout[i + 1][j] === "road";
          const isRoadLeft = j > 0 && cityLayout[i][j - 1] === "road";
          const isRoadRight = j < gridSize - 1 && cityLayout[i][j + 1] === "road";

          const isHorizontal = isRoadLeft || isRoadRight;
          const isVertical = isRoadAbove || isRoadBelow;

          const isIntersection = isHorizontal && isVertical;
          const isEnd = [isRoadAbove, isRoadBelow, isRoadLeft, isRoadRight].filter(Boolean).length === 1;

          if (isIntersection) {
            gridItem.classList.add("intersection");
          } else if (isEnd) {
            if (isRoadAbove || isRoadBelow) {
              gridItem.classList.add("vertical");
            } else {
              gridItem.classList.add("horizontal");
            }
          } else if (isHorizontal) {
            gridItem.classList.add("horizontal");
          } else {
            gridItem.classList.add("vertical");
          }
        }


      }
    }



    // Function to shuffle an array
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function generateCityLayout(size) {
      const layout = [];
      const quarters = ["residential", "industrial", "natural", "water"];
      shuffle(quarters);
      const roadInterval = Math.floor((Math.random() * 1.5) + (Math.random() * 1.5)) + 4; // Randomize the density of the roads
      const turnChance = Math.random() * 0.2 + 0.1; // Randomize the chance of a road turning



      // Create a grid of "residential", "industrial", "natural", and "water" areas
      for (let i = 0; i < size; i++) {
        layout[i] = [];
        for (let j = 0; j < size; j++) {
          const quarter = quarters[Math.floor(i / (size / (2 + Math.random()))) * 2 + Math.floor(j / (size / (2 + Math.random())))];
          layout[i][j] = quarter;
        }
      }



      // Create roads based on the type of the area
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const areaType = layout[i][j];
          if (areaType !== "water") { // Add this line
            if (areaType === "residential" || areaType === "industrial") {
              // Create tightly packed roads for "residential" and "industrial" areas
              if (i % roadInterval === 0 || j % roadInterval === 0) {
                layout[i][j] = "road";
              }
            } else if (areaType === "natural") {
              // Create winding roads for "natural" areas
              if ((i % (2 * roadInterval) < roadInterval && j % roadInterval === 0) ||
                (i % (2 * roadInterval) >= roadInterval && i % roadInterval === 0)) {
                layout[i][j] = "road";
                // Randomly turn the road
                if (Math.random() < turnChance) {
                  if (i % (2 * roadInterval) < roadInterval) {
                    // The road is currently horizontal, so turn it vertical
                    for (let k = i; k < size; k++) {
                      layout[k][j] = "road";
                    }
                  } else {
                    // The road is currently vertical, so turn it horizontal
                    for (let k = j; k < size; k++) {
                      layout[i][k] = "road";
                    }
                  }
                }
              }
            }
          }
        }
      }

      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const areaType = layout[i][j];
          if (areaType !== "road" && areaType !== "water" && areaType !== "natural") {
            if ((i > 0 && layout[i - 1][j] === "road") ||
              (j > 0 && layout[i][j - 1] === "road") ||
              (i < size - 1 && layout[i + 1][j] === "road") ||
              (j < size - 1 && layout[i][j + 1] === "road")) {
              layout[i][j] = "habitable";
            }
          }
        }
      }

      const buildingTypes = ["office-building", "gas-station", "library", "police-station", "fire-station", "admin-buildings", "restaurants", "homes"];
      const buildingLimits = {
        "gas-station": 10,
        "library": 2,
        "police-station": 5,
        "fire-station": 3,
        "restaurants": 10
      };
      const buildingCounts = {
        "gas-station": 0,
        "library": 0,
        "police-station": 0,
        "fire-station": 0,
        "restaurants": 0
      };

      // Generate a list of all habitable locations
      const habitableLocations = [];
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (layout[i][j] === "habitable") {
            habitableLocations.push([i, j]);
          }
        }
      }

      // Shuffle the habitable locations
      shuffle(habitableLocations);

      // Assign buildings to the habitable locations
      for (const [i, j] of habitableLocations) {
        if (Math.random() < 0.7) { // Only assign a building 70% of the time
          let buildingType;
          do {
            buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
          } while (buildingLimits[buildingType] && buildingCounts[buildingType] >= buildingLimits[buildingType]);
          if (buildingType) { // Check that a building type was found
            layout[i][j] = buildingType;
            if (buildingCounts[buildingType] !== undefined) {
              buildingCounts[buildingType]++;
            }
          }
        }
      }

      // Post-processing check for roads
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (layout[i][j] === "road") {
            const neighbors = [
              layout[i - 1] && layout[i - 1][j],
              layout[i + 1] && layout[i + 1][j],
              layout[i][j - 1],
              layout[i][j + 1]
            ].filter(Boolean); // Filter out undefined neighbors
            const nonRoadNeighbors = neighbors.filter(neighbor => neighbor !== "road");
            if (nonRoadNeighbors.length === neighbors.length && nonRoadNeighbors[0]) { // All neighbors are not roads and there is at least one non-road neighbor
              layout[i][j] = nonRoadNeighbors[0]; // Change the road to match its neighbors
            }
          }
        }

      }

      // Post-processing to add beach squares
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (layout[i][j] === "water") {
            const isEdgeOfWaterZone = (
              (i > 0 && layout[i - 1][j] !== "water") ||
              (j > 0 && layout[i][j - 1] !== "water") ||
              (i < size - 1 && layout[i + 1][j] !== "water") ||
              (j < size - 1 && layout[i][j + 1] !== "water")
            );

            if (isEdgeOfWaterZone) {
              for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                  if (i + di >= 0 && i + di < size && j + dj >= 0 && j + dj < size) { // Check that the square is within the grid
                    if (layout[i + di][j + dj] === "empty") {
                      layout[i + di][j + dj] = "beach";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // post processing to check for undefined squares
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (!layout[i][j]) {
            layout[i][j] = "industrial";
          }
        }
      }




      return layout;
    }

    let buildingMode = false;

    document.getElementById('toggle-building-mode').addEventListener('click', () => {
      buildingMode = !buildingMode;

      if (buildingMode) {
        document.getElementById('toggle-building-mode').style.backgroundColor = "#00ff00";
      } else {
        document.getElementById('toggle-building-mode').style.backgroundColor = "transparent";
      }
    });

    const gridItems = document.querySelectorAll('.grid-item');
    gridItems.forEach(item => {
      item.addEventListener('click', () => {
        if (buildingMode && item.classList.contains('habitable')) {
          const buildingType = document.getElementById('building-select').value;
          item.classList.remove('habitable');
          item.classList.add(buildingType);
        }
      });
    });


    var player = {
      money: 0,
      income: 0,
      expenses: 0,
      level: 0
    };


    let panZoomController = panzoom(document.getElementById('world-map'), {
      bounds: true,
      maxZoom: 4,
      minZoom: 1,
      boundsPadding: 1
    });


    const adminBuildingImages = [
      'sprites/admin_building_1.png',
      'sprites/admin_building_2.png',
      'sprites/admin_building_3.png',
    ];

    const restaurantBuildingImages = [
      'sprites/rest_1.png',
      'sprites/rest_2.png',
    ];

    const houseBuildingImages = [
      'sprites/house_1.png',
      'sprites/house_2.png',
      'sprites/house_3.png',
    ];

    const officeBuildingImages = [
      'sprites/office_building_1.png',
    ];

    document.querySelectorAll('.admin-buildings').forEach((building) => {
      const randomImage = adminBuildingImages[Math.floor(Math.random() * adminBuildingImages.length)];
      building.style.backgroundImage = `url('${randomImage}')`;
      building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
    });

    document.querySelectorAll('.restaurants').forEach((building) => {
      const randomImage = restaurantBuildingImages[Math.floor(Math.random() * restaurantBuildingImages.length)];
      building.style.backgroundImage = `url('${randomImage}')`;
      building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
    });

    document.querySelectorAll('.homes').forEach((building) => {
      const randomImage = houseBuildingImages[Math.floor(Math.random() * houseBuildingImages.length)];
      building.style.backgroundImage = `url('${randomImage}')`;
      building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
    });

    document.querySelectorAll('.office-building').forEach((building) => {
      const randomImage = officeBuildingImages[Math.floor(Math.random() * officeBuildingImages.length)];
      building.style.backgroundImage = `url('${randomImage}')`;
      building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
    });

    window.onload = function () {
      document.querySelectorAll('.admin-buildings').forEach((building) => {
        const randomImage = adminBuildingImages[Math.floor(Math.random() * adminBuildingImages.length)];
        building.style.backgroundImage = `url('${randomImage}')`;
        building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
      });

      document.querySelectorAll('.restaurants').forEach((building) => {
        const randomImage = restaurantBuildingImages[Math.floor(Math.random() * restaurantBuildingImages.length)];
        building.style.backgroundImage = `url('${randomImage}')`;
        building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
      });

      document.querySelectorAll('.homes').forEach((building) => {
        const randomImage = houseBuildingImages[Math.floor(Math.random() * houseBuildingImages.length)];
        building.style.backgroundImage = `url('${randomImage}')`;
        building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
      });

      document.querySelectorAll('.office-building').forEach((building) => {
        const randomImage = officeBuildingImages[Math.floor(Math.random() * officeBuildingImages.length)];
        building.style.backgroundImage = `url('${randomImage}')`;
        building.style.filter = `hue-rotate(${Math.floor(Math.random() * 360)}deg)`;
      });

    };


    class Building {
  constructor(name, type, size, location) {
    this.name = name;
    this.type = type;
    this.size = size;
    this.location = location;
  }

  getInfo() {
    return `Name: ${this.name}<br>Type: ${this.type}<br>Size: ${this.size}<br>Location: ${this.location}`;
  }
}

gridItems.forEach((item, index) => {
  // Create a new building instance for each grid item
  let building = new Building(`Building ${index + 1}`, 'Residential', 'Large', `Location ${index + 1}`);
  
  // Store the building info in a data attribute
  item.dataset.info = building.getInfo();
});

tippy('.grid-item', {
  content(reference) {
    return reference.dataset.info;
  },
  allowHTML: true
});

  </script>
</body>

</html>